/* Bison Prologue*/
%{
	#include "part3_helpers.h"
	
	using namespace std;

	int yylex();
	extern int yylineno;
    extern const char* yytext;
	
	Node *root_node;		//root node
	Vec_buf code_buffer;
	variable_table var_table;
	Function_Table func_table;
	
	void yyerror(const char*);
	void semantic_err(string err);
	void operational_err(string err);
%}

/* Bison Declarations */
//no special precedence/associativity
%token INT FLOAT VOID WRITE READ OPTIONAL WHILE DO IF RETURN ID INTEGERNUM REALNUM STR '{' '}' '[' ']' ',' ';' ':'
//precedence and associativity as in C
%right ASSIGN
%left OR
%left AND
%left RELOP
%left ADDOP
%left MULOP
%right NOT '(' ')'  // solving casting-mulop/addop conflicts

// solving else-then conflict
%precedence THEN 
%precedence ELSE 


/* Bison Grammar rules */
%%

PROGRAM :	FDEFS	{ 		//---------------------------------------------rule below finished---------------------------------------------
				root_node = new Node();		//maybe need to change to lower class (like symbol node)
				code_buffer.emit("HALT");	//end of program
			}
;

FDEFS :		FDEFS FUNC_DEF_API BLK { 
				
			}
			| FDEFS FUNC_DEC_API { 
				
			}
			| /* epsilon */ { 
				$$ = new Node();
			}
;

FUNC_DEC_API : TYPE ID '(' ')' ';' { $$ = makeNode("FUNC_DEC_API",NULL,concatList(concatList(concatList(concatList($1,$2),$3),$4),$5)); }
	| TYPE ID '(' FUNC_ARGLIST ')' ';'	{ $$ = makeNode("FUNC_DEC_API",NULL,concatList(concatList(concatList(concatList(concatList($1,$2),$3),$4),$5),$6)); }
	| TYPE ID '(' FUNC_DEC_ARGLIST_OPT ')' ';' { $$ = makeNode("FUNC_DEC_API",NULL,concatList(concatList(concatList(concatList(concatList($1,$2),$3),$4),$5),$6)); }
	| TYPE ID '(' FUNC_ARGLIST ',' FUNC_DEC_ARGLIST_OPT ')' ';' { $$ = makeNode("FUNC_DEC_API",NULL,concatList(concatList(concatList(concatList(concatList(concatList(concatList($1,$2),$3),$4),$5),$6),$7),$8)); }
;

FUNC_DEC_ARGLIST_OPT : FUNC_DEC_ARGLIST_OPT',' DCL_OPT { $$ = makeNode("FUNC_DEC_ARGLIST_OPT",NULL,concatList(concatList($1,$2),$3)); } /* DO WE WANNA KNOW? */
	| DCL_OPT { $$ = makeNode("FUNC_DEC_ARGLIST_OPT",NULL,$1); }
;

DCL_OPT : ID ':' OPTIONAL TYPE { $$ = makeNode("DCL_OPT",NULL,concatList(concatList(concatList($1,$2),$3),$4));}
	| ID',' DCL_OPT { $$ = makeNode("DCL_OPT",NULL,concatList(concatList($1,$2),$3)); }
;

FUNC_DEF_API : TYPE ID '(' ')' { $$ = makeNode("FUNC_DEF_API",NULL,concatList(concatList(concatList($1,$2),$3),$4));}
	| TYPE ID '(' FUNC_ARGLIST ')' { $$ = makeNode("FUNC_DEF_API",NULL,concatList(concatList(concatList(concatList($1,$2),$3),$4),$5)); }
	| TYPE ID '(' FUNC_DEF_ARGLIST_OPT ')' { $$ = makeNode("FUNC_DEF_API",NULL,concatList(concatList(concatList(concatList($1,$2),$3),$4),$5)); }
	| TYPE ID '(' FUNC_ARGLIST ',' FUNC_DEF_ARGLIST_OPT ')' { $$ = makeNode("FUNC_DEF_API",NULL,concatList(concatList(concatList(concatList(concatList(concatList($1,$2),$3),$4),$5),$6),$7)); }
;

FUNC_DEF_ARGLIST_OPT : FUNC_DEF_ARGLIST_OPT ',' DCL_OPT_VAL { $$ = makeNode("FUNC_DEF_ARGLIST_OPT",NULL,concatList(concatList($1,$2),$3)); }
	| DCL_OPT_VAL { $$ = makeNode("FUNC_DEF_ARGLIST_OPT",NULL,$1); }
;

DCL_OPT_VAL : ID ASSIGN NUM ':' OPTIONAL TYPE { $$ = makeNode("DCL_OPT_VAL",NULL,concatList(concatList(concatList(concatList(concatList($1,$2),$3),$4),$5),$6)); }
	| ID ASSIGN NUM ',' DCL_OPT_VAL { $$ = makeNode("DCL_OPT_VAL",NULL,concatList(concatList(concatList(concatList($1,$2),$3),$4),$5)); }
;

FUNC_ARGLIST : FUNC_ARGLIST ',' DCL { $$ = makeNode("FUNC_ARGLIST",NULL,concatList(concatList($1,$2),$3)); }
	| DCL { $$ = makeNode("FUNC_ARGLIST",NULL,$1); }
;

BLK : '{' STLIST '}' { $$ = makeNode("BLK",NULL,concatList(concatList($1,$2),$3)); }
;

DCL : ID ':' TYPE { $$ = makeNode("DCL",NULL,concatList(concatList($1,$2),$3)); }
	| ID ',' DCL { $$ = makeNode("DCL",NULL,concatList(concatList($1,$2),$3)); }
;

TYPE : INT { $$ = makeNode("TYPE",NULL,$1); }
	| FLOAT { $$ = makeNode("TYPE",NULL,$1); }
	| VOID { $$ = makeNode("TYPE",NULL,$1); }
;

STLIST : STLIST STMT { $$ = makeNode("STLIST",NULL,concatList($1,$2)); }
	| /* epsilon */ { $$ = makeNode("STLIST",NULL,makeNode("EPSILON",NULL,NULL)); }
;

STMT : DCL ';' { $$ = makeNode("STMT",NULL,concatList($1,$2)); }
	| ASSN { $$ = makeNode("STMT",NULL,$1); }
	| EXP ';' { $$ = makeNode("STMT",NULL,concatList($1,$2)); }
	| CNTRL { $$ = makeNode("STMT",NULL,$1); }
	| read { $$ = makeNode("STMT",NULL,$1); }
	| write { $$ = makeNode("STMT",NULL,$1); }
	| return { $$ = makeNode("STMT",NULL,$1); }
	| BLK { $$ = makeNode("STMT",NULL,$1); }
;

return : RETURN EXP ';' { $$ = makeNode("RETURN",NULL,concatList(concatList($1,$2),$3)); }
	| RETURN';' { $$ = makeNode("RETURN",NULL,concatList($1,$2)); }
;

write : WRITE '(' EXP ')' ';' { //---------------------------------------------rule below finished-----------------------------------------
		$$ = new Node();
		/*here is the place for dynamic casting to parent but i see no use*/
		ExpSymbol* exp1 = dynamic_cast<ExpSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		string three_add_code;
        if(exp->exp_type == int_){
            three_add_code = string("PRNTI") + " " + exp->place;
			code_buffer.emit(three_add_code);
		}
        else if(exp->exp_type == float_){
            three_add_code = string("PRNTF") + " " + exp->place;
			code_buffer.emit(three_add_code);
		}
		else{	//type == void_t)
            semantic_err("rule 2: can't write to variable of type void");
		}

	}
	| WRITE '(' STR ')' ';' { 
		$$ = new Node();
		/*here is the place for dynamic casting to parent but i see no use*/
		Terminal* str1 = dynamic_cast<Terminal*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		//check special character within string
		string str = str1->terminal_value;
		for(int i = 0; i < str.length(); i++){
			if(str[i] == '\\'){
                i++;
                if(str[i] == 'n'){
                    code_buffer.emit("PRNTC 10");	//ASCII value of \n
				}
				else if(str[i] == 't'){
                    code_buffer.emit("PRNTC 9");	//ASCII value of \t
				}
				else if(str[i] == '"'){
                    code_buffer.emit("PRNTC 34");	//ASCII value of "
				}
                else{	// backslash with no meaning, error
                        operational_err("illegal use of \\");
                }
            }
			else {	//no special character
                string three_add_code = string("PRNTC") + " " + to_string(int(str[i]));		//why int???
				code_buffer.emit(three_add_code);
            }
		}
	}
;

read : READ '(' LVAL ')' ';' { 	//---------------------------------------------rule below finished-----------------------------------------
		$$ = new Node();
		Node* read0 = dynamic_cast<Node*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* lval1 = dynamic_cast<ExpSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		string three_add_code;
		string letter_type = "I";
		if(lval1->exp_type == float_){
			letter_type = "F";
		}
		else if(lval1->exp_type == void_t){		//shouldn't get here
			semantic_err("rule 2: can't read to variable of type void");
		}
		
		string temp_reg = var_table.front().next_temp_reg(lval1->exp_type);
		three_add_code = string("READ")+type + " " + temp_reg;
		code_buffer.emit(three_add_code);
		three_add_code = string("STOR")+type + " " + temp_reg + " " + lval->place + " " + "0";	//again why store and not copy?
		code_buffer.emit(three_add_code);

	}
;

ASSN : LVAL ASSIGN EXP ';' {	//---------------------------------------------rule below finished-----------------------------------------
		$$ = new StmtSymbol();
		StmtSymbol* assn0 = dynamic_cast<StmtSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* lval1 = dynamic_cast<ExpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp1 = dynamic_cast<ExpSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		if(lval1->exp_type != exp1->exp_type){	
			semantic_err("rule 1: assignment between different types is not allowed");
		}

		string letter_type = "I";
		if(lval1->exp_type == float_){
			letter_type = "F";
		}
		else if(lval1->exp_type == void_t){		//shouldn't get here
			semantic_err("rule 2: can't assign to variable of type void");
		}
		string three_add_code = string("STOR")+letter_type + " " + exp1->place + " " + lval1->place + " " + "0";	//why store and not copy?
		code_buffer.emit(three_add_code);

	}
;

LVAL : ID {     		//---------------------------------------------rule below finished-------------------------------------------------
		$$ = new ExpSymbol();
		ExpSymbol* lval0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* id1 = dynamic_cast<Terminal*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		//checking if variable ID is declared
		Var_Table_Entry var_entry;
		if(!var_table.is_var_exist(var_entry, id1->terminal_value)){
			string err = "variable '" + id1->terminal_value + "' is not declared";
			semantic_err(err);
		}

		string three_add_code;
		string temp_reg = var_table.front().next_temp_reg(int_);
		three_add_code = string("ADD2I") + " " + temp_reg + " " + DP + " " + to_string(var_entry.offset);
		code_buffer.emit(three_add_code);

        lval->place = temp_reg;		//update parent symbol place
		lval->exp_type = var_entry.type;	//update parent symbol type

		if(var_entry.type == float_){
                    string float_reg = varTable.front().next_temp_reg(float_);
                    three_add_code = string("CITOF") + " " + float_reg + " " + temp_reg;
					code_buffer.emit(three_add_code);
                    lval->place = float_reg;
        }
	}
;

CNTRL : IF BEXP THEN M STMT ELSE N M STMT {     //--------------------------------------rule below finished--------------------------------
		$$ = new StmtSymbol();
		StmtSymbol* cntrl0 = dynamic_cast<StmtSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		BexpSymbol* bexp1 = dynamic_cast<BexpSymbol*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Marker_M_Symbol* M1 = dynamic_cast<Marker_M_Symbol*>($4);	//don't know if necessary, maybe work dircetly through $$,S1,...
		StmtSymbol* stmt1 = dynamic_cast<StmtSymbol*>($5);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Marker_N_Symbol* N1 = dynamic_cast<Marker_N_Symbol*>($7);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Marker_M_Symbol* M2 = dynamic_cast<Marker_M_Symbol*>($8);	//don't know if necessary, maybe work dircetly through $$,S1,...
		StmtSymbol* stmt2 = dynamic_cast<StmtSymbol*>($9);	//don't know if necessary, maybe work dircetly through $$,S1,...

		code_buffer.backpatch(bexp1->truelist, M1->quad);
        code_buffer.backpatch(bexp1->falselist, M2->quad);
        cntrl0->nextlist.merge(N1->nextlist);
        cntrl0->nextlist.merge(stmt1->nextlist);
        cntrl0->nextlist.merge(stmt2->nextlist);
        cntrl0->breaklist.merge(stmt1->breaklist);
        cntrl0->breaklist.merge(stmt2->breaklist);

	}
	| IF BEXP THEN M STMT { 
		$$ = new StmtSymbol();
		StmtSymbol* cntrl0 = dynamic_cast<StmtSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		BexpSymbol* bexp1 = dynamic_cast<BexpSymbol*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Marker_M_Symbol* M1 = dynamic_cast<Marker_M_Symbol*>($4);	//don't know if necessary, maybe work dircetly through $$,S1,...
		StmtSymbol* stmt1 = dynamic_cast<StmtSymbol*>($5);	//don't know if necessary, maybe work dircetly through $$,S1,...

		code_buffer.backpatch(bexp1->truelist, M1->quad);
		cntrl0->nextlist.merge(bexp1->falselist);
		cntrl0->nextlist.merge(stmt1->nextlist);
		cntrl0->breaklist.merge(stmt1->breaklist);

	}
	| WHILE M BEXP DO M STMT { 
		$$ = new StmtSymbol();
		StmtSymbol* cntrl0 = dynamic_cast<StmtSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Marker_M_Symbol* M1 = dynamic_cast<Marker_M_Symbol*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...
		BexpSymbol* bexp1 = dynamic_cast<BexpSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Marker_M_Symbol* M2 = dynamic_cast<Marker_M_Symbol*>($5);	//don't know if necessary, maybe work dircetly through $$,S1,...
		StmtSymbol* stmt1 = dynamic_cast<StmtSymbol*>($6);	//don't know if necessary, maybe work dircetly through $$,S1,...

		code_buffer.backpatch(bexp1->truelist, M2->quad);
		code_buffer.backpatch(stmt1->nextlist, M1->quad);
		cntrl0->nextlist.merge(bexp1->falselist);
		cntrl0->nextlist.merge(stmt1->breaklist);
		string three_add_code = string("UJUMP") + " " + to_string(M1->quad);
		code_buffer.emit(three_add_code);
	}
;

BEXP : BEXP OR M BEXP {    		//---------------------------------------------rule below finished-----------------------------------------
		$$ = new BexpSymbol();
		BexpSymbol* bexp0 = dynamic_cast<BexpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,... 
		BexpSymbol* bexp1 = dynamic_cast<BexpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,... 
		Marker_M_Symbol* M = dynamic_cast<Marker_M_Symbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,... 
		BexpSymbol* bexp2 = dynamic_cast<BexpSymbol*>($4);	//don't know if necessary, maybe work dircetly through $$,S1,... 

		code_buffer.backpatch(bexp1->falselist, M->quad);
        bexp0->truelist.merge(bexp1->truelist);
        bexp0->truelist.merge(bexp2->truelist);
        bexp0->falselist.merge(bexp2->falselist);
	} 
	| BEXP AND M BEXP { 
		$$ = new BexpSymbol();
		BexpSymbol* bexp0 = dynamic_cast<BexpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,... 
		BexpSymbol* bexp1 = dynamic_cast<BexpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,... 
		Marker_M_Symbol* M = dynamic_cast<Marker_M_Symbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,... 
		BexpSymbol* bexp2 = dynamic_cast<BexpSymbol*>($4);	//don't know if necessary, maybe work dircetly through $$,S1,... 

		code_buffer.backpatch(bexp1->truelist, M->quad);
		bexp0->truelist.merge(bexp2->truelist);	
		bexp0->falselist.merge(bexp1->falselist);
		bexp0->falselist.merge(bexp2->falselist);
	}
	| NOT BEXP { 
		$$ = new BexpSymbol();
		BexpSymbol* bexp0 = dynamic_cast<BexpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,... 
		BexpSymbol* bexp1 = dynamic_cast<BexpSymbol*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,... 

		//swap true and false lists in assignment to parent symbol
		bexp->truelist.merge(bexp1->falselist);
		bexp->falselist.merge(bexp1->truelist);
	}
	| EXP RELOP EXP { 
		$$ = new BexpSymbol();
		BexpSymbol* bexp0 = dynamic_cast<BexpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...  
		ExpSymbol* exp1 = dynamic_cast<ExpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* relop2 = dynamic_cast<Terminal*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp3 = dynamic_cast<ExpSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		if(exp1->exp_type != exp3->exp_type){	
			semantic_err("RELOP operation between different types is not allowed");
		}
		if(exp1->exp_type == void_t || exp3->exp_type == void_t){	
			semantic_err("RELOP operation is not allowed on type void");
		}

		string three_add_code;
		string result_reg = var_table.front().next_temp_reg(int_);	//assume it's int, otherwise need casting
		string letter_type = "I";
		if(exp1->exp_type == float_){
			letter_type = "F";
		}

		switch(relop2->terminal_value){
		case "==":
			if(exp1->exp_type == float_){
				string float_reg = var_table.front().next_temp_reg(float_);
				three_add_code = string("SEQUF") + " " + float_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
				//now casting the result to int
				three_add_code = string("CFTOI") + " " + result_reg + " " + float_reg;
				code_buffer.emit(three_add_code);
			}
			else{	//type int, no casting
				three_add_code = string("SEQUI") + " " + result_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
			bexp->truelist.push_back(code_buffer.nextQuad());
            three_add_code = string("BNEQZ") + " " + result_reg + " " + "-1";	//expressions equal --> res=1 , why the emit is here???????????
			code_buffer.emit(three_add_code); 
            break;
		case "<>":
			if(exp1->exp_type == float_){
				string float_reg = var_table.front().next_temp_reg(float_);
				three_add_code = string("SNEQF") + " " + float_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
				//now casting the result to int
				three_add_code = string("CFTOI") + " " + result_reg + " " + float_reg;
				code_buffer.emit(three_add_code);
			}
			else{	//type int, no casting
				three_add_code = string("SNEQI") + " " + result_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
			bexp->truelist.push_back(code_buffer.nextQuad());
            three_add_code = string("BNEQZ") + " " + result_reg + " " + "-1";	// why the emit is here???????????
			code_buffer.emit(three_add_code); 
            break;
		case "<":
			if(exp1->exp_type == float_){
				string float_reg = var_table.front().next_temp_reg(float_);
				three_add_code = string("SLETF") + " " + float_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
				//now casting the result to int
				three_add_code = string("CFTOI") + " " + result_reg + " " + float_reg;
				code_buffer.emit(three_add_code);
			}
			else{	//type int, no casting
				three_add_code = string("SLETI") + " " + result_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
			bexp->truelist.push_back(code_buffer.nextQuad());
            three_add_code = string("BNEQZ") + " " + result_reg + " " + "-1";	// why the emit is here???????????
			code_buffer.emit(three_add_code); 
            break;
		case "<=":
			if(exp1->exp_type == float_){
				string float_reg = var_table.front().next_temp_reg(float_);
				three_add_code = string("SGRTF") + " " + float_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
				//now casting the result to int
				three_add_code = string("CFTOI") + " " + result_reg + " " + float_reg;
				code_buffer.emit(three_add_code);
			}
			else{	//type int, no casting
				three_add_code = string("SGRTI") + " " + result_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
			bexp->truelist.push_back(code_buffer.nextQuad());
            three_add_code = string("BREQZ") + " " + result_reg + " " + "-1";	//exp1 <= exp3 --> res=0 , why the emit is here???????????
			code_buffer.emit(three_add_code); 
            break;
		case ">":
			if(exp1->exp_type == float_){
				string float_reg = var_table.front().next_temp_reg(float_);
				three_add_code = string("SGRTF") + " " + float_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
				//now casting the result to int
				three_add_code = string("CFTOI") + " " + result_reg + " " + float_reg;
				code_buffer.emit(three_add_code);
			}
			else{	//type int, no casting
				three_add_code = string("SGRTI") + " " + result_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
			bexp->truelist.push_back(code_buffer.nextQuad());
            three_add_code = string("BNEQZ") + " " + result_reg + " " + "-1";	// why the emit is here???????????
			code_buffer.emit(three_add_code); 
            break;
		case ">=":
			if(exp1->exp_type == float_){
				string float_reg = var_table.front().next_temp_reg(float_);
				three_add_code = string("SLETF") + " " + float_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
				//now casting the result to int
				three_add_code = string("CFTOI") + " " + result_reg + " " + float_reg;
				code_buffer.emit(three_add_code);
			}
			else{	//type int, no casting
				three_add_code = string("SLETI") + " " + result_reg + " " + exp1->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
			bexp->truelist.push_back(code_buffer.nextQuad());
            three_add_code = string("BREQZ") + " " + result_reg + " " + "-1";	//exp1 <= exp3 --> res=0 , why the emit is here???????????
			code_buffer.emit(three_add_code); 
            break;
		default:
			operational_err("the operator is not RELOP");
			break;
		}	//switch closing braces

		bexp->falselist.push_back(code_buffer.nextQuad());	//update parent falselist
		code_buffer.emit(string("UJUMP -1"));

	} 
	| '(' BEXP ')' { 
		$$ = new BexpSymbol();
		BexpSymbol* bexp0 = dynamic_cast<BexpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...        
        BexpSymbol* bexp1 = dynamic_cast<BexpSymbol*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...

		bexp0->truelist = bexp1->truelist;        
        bexp0->falselist = bexp1->falselist; 
	}
;

EXP : EXP ADDOP EXP {    		//---------------------------------------------rule below finished-----------------------------------------
		$$ = new ExpSymbol();
		ExpSymbol* exp0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp1 = dynamic_cast<ExpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* addop2 = dynamic_cast<Terminal*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp3 = dynamic_cast<ExpSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		if(exp1->exp_type != exp3->exp_type){	
			semantic_err("ADDOP operation between different types is not allowed");
		}
		if(exp1->exp_type == void_t || exp3->exp_type == void_t){	
			semantic_err("ADDOP operation is not allowed on type void");
		}

		string three_add_code;
		string result_reg = var_table.front().next_temp_reg(exp1->exp_type);
		string letter_type = "I";
		if(exp1->exp_type == float_){
			letter_type = "F";
		}

		if(addop2->terminal_value == '+'){
			three_add_code = string("ADD2") + letter_type + " " + result_reg + " " + exp1->place + " " + exp3->place;
			code_buffer.emit(three_add_code);
		}
		else if(addop2->terminal_value == '-'){
			three_add_code = string("SUBT") + letter_type + " " + result_reg + " " + exp1->place + " " + exp3->place;
			code_buffer.emit(three_add_code);
		}
		else{	//operational error
			operational_err("the operator is not ADDOP");
		}

		exp0->place = result_reg;		//update parent symbol place
		exp0->exp_type = exp1->exp_type;	//update parent symbol type

	}
	| EXP MULOP EXP { 
		$$ = new ExpSymbol();
		ExpSymbol* exp0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp1 = dynamic_cast<ExpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* mulop2 = dynamic_cast<Terminal*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp3 = dynamic_cast<ExpSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		if(exp1->exp_type != exp3->exp_type){	
			semantic_err("MULOP operation between different types is not allowed");
		}
		if(exp1->exp_type == void_t || exp3->exp_type == void_t){	
			semantic_err("MULOP operation is not allowed on type void");
		}

		string three_add_code;
		string result_reg = var_table.front().next_temp_reg(exp1->exp_type);
		string letter_type = "I";
		if(exp1->exp_type == float_){
			letter_type = "F";
		}

		if(mulop2->terminal_value == '*'){
			three_add_code = string("MULT") + letter_type + " " + result_reg + " " + exp1->place + " " + exp3->place;
			code_buffer.emit(three_add_code);
		}
		else if(mulop2->terminal_value == '/'){
			three_add_code = string("DIVD") + letter_type + " " + result_reg + " " + exp1->place + " " + exp3->place;
			code_buffer.emit(three_add_code);
		}
		else{	//operational error
			operational_err("the operator is not MULOP");
		}

		exp0->place = result_reg;		//update parent symbol place
		exp0->exp_type = exp1->exp_type;	//update parent symbol type

	}
	| '(' EXP ')' { 
		$$ = new ExpSymbol();
		ExpSymbol* exp0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp1 = dynamic_cast<ExpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		exp0->place = exp1->place;		//update parent symbol place
		exp0->exp_type = exp1->exp_type;	//update parent symbol type
	}
	| '(' TYPE ')' EXP { 
		$$ = new ExpSymbol();
		ExpSymbol* exp0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		TypeSymbol* type1 = dynamic_cast<TypeSymbol*>($2);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp2 = dynamic_cast<ExpSymbol*>($4);	//don't know if necessary, maybe work dircetly through $$,S1,...

		string three_add_code;
		if(type1->type_value == exp2->exp_type){	//sam type, no casting needed
			exp0->place = exp2->place;		//update parent symbol place
			exp0->exp_type = exp2->exp_type;	//update parent symbol type
		}
		else{
			if(type1->type_value == void_t || exp2->exp_type == void_t){
				semantic_err("casting from/to type void is not allowed");
			}
			else if(type1->type_value == int_){	//we can change the cond to exp2->exp_type == float_
				exp0->place = var_table.front().next_temp_reg(int_);
				three_add_code = string("CFTOI") + " " + exp0->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
			else{	//type == float_
				exp0->place = var_table.front().next_temp_reg(float_);
				three_add_code = string("CITOF") + " " + exp0->place + " " + exp2->place;
				code_buffer.emit(three_add_code);
			}
		}

	}
	| ID { 
		$$ = new ExpSymbol();
		ExpSymbol* exp0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* id1 = dynamic_cast<Terminal*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		//checking if variable ID is declared
		Var_Table_Entry var_entry;
		if(!var_table.is_var_exist(var_entry, id1->terminal_value)){
			string err = "variable '" + id1->terminal_value + "' is not declared";
			semantic_err(err);
		}

		string three_add_code;
		string temp_reg = var_table.front().next_temp_reg(var_entry.type);
		if(var_entry.type = float_){
			three_add_code = string("CITOF") + " " + DP_F + " " + DP;
			code_buffer.emit(three_add_code);
			three_add_code = string("LOADF") + " " + temp_reg + " " + DP_F + " " + to_string(var_entry.offset);
			code_buffer.emit(three_add_code);
		}
		else if(var_entry.type = int_){
			three_add_code = string("LOADI") + " " + temp_reg + " " + DP + " " + to_string(var_entry.offset);
			code_buffer.emit(three_add_code);
		}
		else{	//type == void , shouldn't get here
			semantic_err("rule 2: can't declare variable of type void");
		}

		exp0->place = temp_reg;		//update parent symbol place
		exp0->exp_type = var_entry.type;	//update parent symbol type

	}
	| NUM { 
		$$ = new ExpSymbol();
		ExpSymbol* exp0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* num1 = dynamic_cast<ExpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		exp0->place = num1->place;		//update parent symbol place
		exp0->exp_type = num1->exp_type;	//update parent symbol type
	}
	| CALL { 
		$$ = new ExpSymbol();
		ExpSymbol* exp0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* call1 = dynamic_cast<ExpSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		exp0->place = call1->place;		//update parent symbol place
		exp0->exp_type = call1->exp_type;	//update parent symbol type
	}
;

NUM : INTEGERNUM {   		//---------------------------------------------rule below finished---------------------------------------------
		$$ = new ExpSymbol();
		ExpSymbol* num0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* int1 = dynamic_cast<Terminal*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		num0->place = var_table.front().next_temp_reg(int_);	//update parent symbol place
		num0->exp_type = int_;		//update parent symbol type
		string three_add_code = string("COPYI") + " " + num0->place + " " + int1->terminal_value;
		code_buffer.emit(three_add_code);
	}
	| REALNUM { 
		$$ = new ExpSymbol();
		ExpSymbol* num0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* real1 = dynamic_cast<Terminal*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		num0->place = var_table.front().next_temp_reg(float_);	//update parent symbol place
		num0->exp_type = float_;	//update parent symbol type
		string three_add_code = string("COPYF") + " " + num0->place + " " + real1->terminal_value;
		code_buffer.emit(three_add_code);
	}
;

CALL : ID '(' CALL_ARGS ')' {  		//---------------------------------------------rule below finished-------------------------------------
		$$ = new ExpSymbol();
		ExpSymbol* call0 = dynamic_cast<ExpSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		Terminal* id1 = dynamic_cast<Terminal*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...
		CallArgsSymbol* call_args1 = dynamic_cast<CallArgsSymbol*>($3);	//don't know if necessary, maybe work dircetly through $$,S1,...

		Function_Table_Entry* func_entry = func_table.find_func_entry(id1->terminal_value);
		if(func_entry == NULL){
			string err = "function '" + id1->terminal_value + "' is not declared";
			semantic_err(err);
		}
		if(call_args1->exp_args.size() != func_entry->func_args.size()){
            string err = string("wrong number of arguments passed to function '") + id1->terminal_value +"'";
			semantic_error(err);
		}

		string three_add_code;
		var_table.store();	//for each var: Mem[SP++] = var
        three_add_code = string("STORI") + " " + RA + " " + SP + " " + "0";	//Mem[SP] = RA
		code_buffer.emit(three_add_code);
		three_add_code = string("STORI") + " " + DP + " " + SP + " " + "4";	//Mem[SP+1*4] = DP
        code_buffer.emit(three_add_code); 
		three_add_code = string("STORI") + " " + FP + " " + SP + " " + "8";	//Mem[SP+2*4] = FP
        code_buffer.emit(three_add_code); 

		three_add_code = string("ADD2I") + " " + FP + " " + SP + " " + "8";	//updating frame pointer (need clearer explanation)
		code_buffer.emit(three_add_code);

		//Cast FP to FP_F - DON'T KNOW WHY!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        three_add_code = string("CITOF") + " " + FP_F + " " + FP;
		code_buffer.emit(three_add_code);
		//?????????????????????????????????????????????????????????????????????????????????????????

		/***** pre-call - store arguments, update dp and sp *****/
		
		//store arguments in stack before call
		int i = 1;	//
        auto func_arg_it = func_entry->func_args.begin();
        auto exp_arg_it = call_args1->exp_args.begin();

		for(;func_arg_it != func_entry->func_args.end();i++, func_arg_it++, exp_arg_it++){
            
			if(exp_arg_it->exp_type != func_arg_it->type){
				string err = string("rule 3: wrong type of argument passed to function '") + id1->terminal_value +"'";
				semantic_error(err);
			}

            if(func_arg_it->type == int_){
                three_add_code = string("STORI") + " " + exp_arg_it->place + " " + FP + " " + to_string(i * 4);
				code_buffer.emit(three_add_code);
            } else if (func_arg_it->type == float_){
                three_add_code = string("STORF") + " " + exp_arg_it->place + " " + FP_F + " " + to_string(i * 4);
				code_buffer.emit(three_add_code);
            } else {
                semantic_err("rule 2: can't pass parameter of type void to function ");
            }
		}

		//set DP on the first arg
        three_add_code = string("ADD2I") + + " " DP + " " + FP + " " + to_string(4);
		code_buffer.emit(three_add_code);
        //set SP above arguments
		three_add_code = string("ADD2I") + " " + SP + " " + FP + " " + to_string((func_entry->func_args.size() + 1) * 4);
        code_buffer.emit(three_add_code);
        
		//jump to definition line of function
        three_add_code = string("JLINK") + " " + func_entry->get_func_def_place(code_buffer.nextQuad());
        code_buffer.emit(three_add_code);

		/***** post-call - restore SP, FP *****/
        
		three_add_code = string("COPYI") + SP + FP; //SP = FP
        code_buffer.emit(three_add_code);
		three_add_code = "LOADI" + " " + FP + " " + FP + " " + "0";	//FP = Mem[FP+0]	
        code_buffer.emit(three_add_code);
		three_add_code = string("SUBTI") + " " + SP + " " + SP + " " + "8";		//SP-=2*4
        code_buffer.emit(three_add_code); 
		three_add_code = string("LOADI") + " " + DP + " " + SP + " " + "4";		//DP = Mem[SP+1*4]
        code_buffer.emit(three_add_code); 
		three_add_code = string("LOADI") + " " + RA + " " + SP + " " + "0";		//RA = Mem[SP]
        code_buffer.emit(); 
        var_table.load();  //for each var: var = Mem[--SP]

		//update parent symbol

		call0->exp_type = func_entry->ret_type;	//updates return type
        //store the return value
        if(func_entry->ret_type == int_){
                call0->place = var_table.front().next_temp_reg(int_);
                three_add_code = string("COPYI") + " " + call->place + " " + RT_I;
				code_buffer.emit(three_add_code);
        } else if(func_entry->ret_type == float_){
                call0->place = var_table.front().next_temp_reg(float_);
                three_add_code = string("COPYF") + " " + call->place + " " + RT_F;
				code_buffer.emit(three_add_code);
        }

        

	}	//rule closing braces
;

CALL_ARGS : CALL_ARGLIST { 		//---------------------------------------------rule below finished-----------------------------------------
		$$ = new CallArgsSymbol();
		CallArgsSymbol* call_arg0 = dynamic_cast<CallArgsSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		CallArgsSymbol* call_arglist1 = dynamic_cast<CallArgsSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...

		call_arg0->exp_args = call_arglist1->exp_args;	//parent symbol gets son symbol expressions
	}
	| /* epsilon */ { 
		$$ = new CallArgsSymbol();
	}
;

CALL_ARGLIST : CALL_ARGLIST ',' EXP { 		//---------------------------------------------rule below finished-----------------------------
		$$ = new CallArgsSymbol();
		CallArgsSymbol* call_arglist0 = dynamic_cast<CallArgsSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		CallArgsSymbol* call_arglist1 = dynamic_cast<CallArgsSymbol*>($1);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp = dynamic_cast<ExpSymbol*>($3);					//don't know if necessary, maybe work dircetly through $$,S1,...

		if(exp->exp_type == void_t){
			semantic_err("rule 2: can't declare function parameter of type void");
		}
		call_arglist0->exp_args = call_arglist1->exp_args;	//parent symbol gets son symbol expressions
		call_arglist0->exp_args.push_back(*exp);			//adding exp to parent expression vector

	}
	| EXP { 
		$$ = new CallArgsSymbol();
		CallArgsSymbol* call_arglist0 = dynamic_cast<CallArgsSymbol*>($$);	//don't know if necessary, maybe work dircetly through $$,S1,...
		ExpSymbol* exp = dynamic_cast<ExpSymbol*>($3);					//don't know if necessary, maybe work dircetly through $$,S1,...

		if(exp->exp_type == void_t){
			semantic_err("rule 2: can't declare func parameter of type void");
		}
		call_arglist0->exp_args.push_back(*exp);			//adding exp to parent expression vector
	}
;

N : /* epsilon */ {		//---------------------------------------------rule below finished-------------------------------------------------
		Marker_M_Symbol* M = new Marker_M_Symbol();
		M->quad = code_buffer.nextquad();
		$$ = M;
	}
;

M : /* epsilon */ {		//---------------------------------------------rule below finished-------------------------------------------------
		Marker_N_Symbol* N = new Marker_N_Symbol();
		N->nextlist.pushback(code_buffer.nextquad());
		code.emit("UJUMP -1");
		$$ = N;
	}
;

%%

/* Bison Epilogue */

void yyerror(const char*){
	printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
	exit(2);
}

void semantic_err(string err){
	printf("semantic error: '%s' in line number %d\n", err, yylineno);
	exit(3);
}

void operational_err(string err){
	printf("Operational error: %s\n", err);
	exit(9);
}